# Design Considerations
Support for a sane syntactical structure:
- no LoadArg-esque instructions to avoid odd instruction args
- furthermore block parameters are declared explicitly

Simple and somewhat flat representation:
- no nested blocks (looking at MLIR)

# Example
The best thing in understanding something are examples.
Some C code and it's radix textual representation:
```c
int fib(int n) {
    if (n < 2) return n;
    return fib(n-1) + fib(n-2);
}
int main(void) {
    return fib(5);
}
```
```radix
--- fib unit
function fib(!0: int):
    @0  | getArg !0
    @1  | const 2
    @2  | less @0 @1
    @3  | if @2 then ret [@0] else b1 []
                 // branching to ret is done by using -1 as the
                 // block index in the branch instruction, as that
                 // should be 2^32 - 1, which is never going to be
b1:              // used
    @5  | const 1
    @6  | sub @0 @5
    @7  | call fib [@6] // fib(n-1)
    @8  | const 2
    @9  | sub @0 @8
    @10 | call fib [@9] // fib(n-2)
    @11 | add @7 @10
    @12 | br ret [@11]
ret(!0: int):    // the exit point is a ret block, which takes the
    return !0    // returned value as a parameter
                 // it directly accesses the blocks param, as it
                 // is autogenerated and only ever accesses it
    
--- main unit
function main(): // the entry point of a function is an implicit b0 block
    @0 | const 5 // it's parameters are the params of the function
    @1 | call fib [@0]
    @2 | br ret [@2]
ret(!0: int):    // compound types like structs can instead be
    return !0    // constructed in the caller function's stackframe
                 // and then the function really returns nothing
```
Note the unit annotations in the radix ir: unit's are the blocks on
which radix operates, they only ever contain a single function.
This makes the referencing of functions interesting, as they are
almost always in a different unit. As such calls and similar operations
have to reference units, rather than functions. This does make
certain types of compilers (aka. single-pass compilers) more powerful
as, ignoring the typechecking step, the functions can be resolved
at this step independently, as their ordering does not exist.
So in reality a function looks like this:
```c
int fact(int n) {
    if (n < 2) return 1;
    return n * fact(n-1);
}
int main(void) {
    return fact(4);
}
```
```radix
--- #0: fact unit
b0(!0: int):
    @0 | getArg !0
    @1 | const 2
    @2 | less @0 @1
    @3 | const 1
    @4 | if @2 then ret [@3] else b1 []
b1():
    @5 | const 1
    @6 | sub @0 @5
    @7 | call #0 [@6]
    @8 | mult @0 @7
    @9 | br ret [@8]
ret(!0: int):
    return !0

--- #1: main unit
b0():
    @0 | const 4
    @1 | call #0 [@0]
    @2 | br ret [@1]
ret(!0: int):
    return !0
```
